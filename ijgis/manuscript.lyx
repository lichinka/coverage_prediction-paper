#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass tGIS2e
\begin_preamble
%
% Format of Figure cross-references
%
\usepackage{prettyref}
\newrefformat{fig}{Figure~\ref{#1}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tbh
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
doi{10.1080/1365881YYxxxxxxxx}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
title{
\end_layout

\end_inset

High-performance computing for GRASS GIS: a case study
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
author{Lucas~Benedi
\backslash
v{c}i
\backslash
v{c}$^{a}$$^{
\backslash
ast}$
\backslash
thanks{$^
\backslash
ast$Corresponding author.
 Email: lucas.benedicic@telekom.si
\backslash
vspace{6pt}}, Felipe~A.~Cruz$^{b}$, Tsuyoshi~Hamada$^{b}$ and Peter~Koro
\backslash
v{s}ec$^{c}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
vspace{6pt} $^{a}${
\backslash
em{Research and Development department, Telekom Slovenije, d.d., Cigaletova
 15, SI-1000 Ljubljana, Slovenia}}; $^{b}${
\backslash
em{Nagasaki Advanced Computer Center, Nagasaki University, 1-14 Bunkyo-machi,
 Nagasaki-city, Nagasaki, 852-8521, Japan}}; $^{c}${
\backslash
em{Computer Systems department, Jo
\backslash
v{z}ef Stefan Institute, Jamova cesta 39, SI-1000 Ljubljana, Slovenia}}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
vspace{6pt}
\backslash
received{Received 10 March 2013}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Practically all studies carried out within GIS can benefit from an improved
 performance.
 A great proportion of these approaches support working on disjoint data
 processing in an isolated fashion.
 For these category of problems, we investigate the challenges and advantages
 of high-performance computing to help dealing with complex calculations
 over big data sets.
 To this end, we present the design and implementation of a parallel radio-cover
age prediction tool for GRASS GIS.
 The radio-coverage prediction calculation is used to introduce and analyze
 various patterns for parallel-algorithm design that are common to problems,
 dealing with geographical data.
 The presented patterns put a special emphasis on usability, making practically
 no restrictions about the type of equipment or environment that may be
 exploited as a high-performance computer cluster.
 Starting from the serial version of a similar tool, and combining a master/slav
e programming model, we provide an extended analysis of the experimental
 results, which are based on real data from an LTE network currently deployed
 in Slovenia.
 According to the experiments, which are performed on a computer cluster,
 the presented programming patterns allow the parallel radio-coverage prediction
 tool to reach great scalability, meaning it is able to tackle real-world
 sized data sets while greatly reducing the processing time and maximizing
 hardware utilization.
 Moreover, we are able to solve problem instances, which sizes are out of
 reach of the reference serial implementation.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{keywords}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
HPC, parallel, simulation, GRASS, GIS, MPI, Mobile networks, LTE.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{keywords}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
By improving the speed performance and data-set sizes a well-known approach
 may handle, we are constantly opening new possibilities for research of
 new models and implementation of enhanced analytical methods.
 Geographic information sciences are no exception to this rule, especially
 because they are a traditional rich source of large data sets 
\begin_inset CommandInset citation
LatexCommand citep
key "Clematis_High_performance_computing_with_geographical_data:2003,Hawick_Distributed_frameworks_and_parallel_algorithms_for_processing_large_scala_geographic_data:2003"

\end_inset

.
 During recent years, many authors have presented studies which show the
 benefits of high-performance computing (HPC) and parallel programming in
 the area of geographical information analysis and decision support.
 It comes to no surprise that the tool of choice on which most of these
 works have focused is geographic information systems (GIS).
 The importance of these systems is further increased as they are generally
 the gathering point of interdisciplinary research, which employs geographical
 data for different kinds of problem-solving 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010,Osterman_CUDA_on_GRASS:2012,Xiao_A_unified_conceptual_framework_for_geographical_optimization_using_evolutionary_algorithms:2008,Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

, analysis and decision support 
\begin_inset CommandInset citation
LatexCommand citep
key "Densham_Spatial_decision_support_systems:1991,Jankowski_Spatial_group_choice_a_SDDS_tool_for_collaborative_spatial_decision_making:1997,Simao_Web_based_GIS_for_collaborative_planning_and_public_participation_an_application_to_the_strategic_planning_of_wind_farm_sites:2009"

\end_inset

.
\end_layout

\begin_layout Standard
Another approach when dealing with computationally expensive problem solving
 is to simplify the models in order to be able to execute their calculations
 within a feasible amount of time.
 Clearly, this increases the introduced error level, which is not an option
 for certain group of simulations, especially those dealing with disaster
 contingency planning and risk analysis 
\begin_inset CommandInset citation
LatexCommand citep
key "Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

.
\end_layout

\begin_layout Standard
Although the well-known and often cited Gordon Moore's prediction from 1965
 still holds 
\begin_inset CommandInset citation
LatexCommand citep
key "Moore_Cramming_more_components_onto_integrated_circuits:1998"

\end_inset

, the fact is that for the last few years, CPU speed is hardly improving.
 Instead, the number of cores within a single CPU is growing.
 This fact poses a challenge for software development in general and research
 in particular: a hardware upgrade will, most of the time, fail to deliver
 twice the computing capacity of its predecessor.
 However, since this commodity hardware is present in practically all modern
 desktop computers, it creates an opportunity for the exploitation of these
 parallel computing resources to enhance the performance of complex algorithms
 over large data sets.
 The challenge is thus to deliver the computing power of multi-core systems
 into a GIS.
 Moreover, by accessing many of such computing nodes through a network connectio
n, the palette of possibilities is even wider.
\end_layout

\begin_layout Standard
A group of studies has successfully deployed HPC systems and techniques
 to solve different problems dealing with spatial data 
\begin_inset CommandInset citation
LatexCommand citep
key "Armstrong_Using_a_computational_grid_for_geographic_information_analysis:2005,Li_Parallel_cellular_automata_for_large_scale_urban_simulation_using_load_balancing_techniques:2010,Guan_A_parallel_computing_approach_to_fast_geostatistical_areal_interpolation:2011,Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012,Osterman_CUDA_on_GRASS:2012,Tabik_Simultaneous_computation_of_total_viewshed_on_large_high_resolution_grids:2012,Widener_Developing_a_parallel_computational_implementation_of_AMOEBA:2012"

\end_inset

.
 Unfortunately, despite some rare exceptions, most of these works are applicatio
n-specific and do not focus on introducing general principles for joining
 GIS and HPC.
 There are several reasons for this, but the most widely known fact is that
 parallel programming and HPC often call for area experts in order to integrate
 these practices in a given environment 
\begin_inset CommandInset citation
LatexCommand citep
key "Clematis_High_performance_computing_with_geographical_data:2003"

\end_inset

.
 Moreover, the wide range of options currently offered create even more
 barriers for general users willing to reach HPC.
\end_layout

\begin_layout Standard
Our work aims at shedding some light over this inherent complexity, by proposing
 some key patterns, and combining them with a relational database, so that
 any group of desktop computers can be easily transformed in a computer
 cluster and its computing capacity exploited.
\end_layout

\begin_layout Standard
In this paper, we combine proved principles of high-performance computing
 with new approaches in order to improve the performance speed of GIS modules.
 As a proof of concept, we implement a parallel radio-prediction tool for
 the open source Geographic Resources Analysis Support System (GRASS).
 For its architecture, we have focused on scalability, clean design and
 open nature of the tool, inspired by the GRASS GIS.
 These facts make it an ideal candidate for demonstrating the benefits of
 the presented patterns, while tackling radio-predictions of big problem
 instances, i.e.
 real mobile networks containing thousands of transmitters.
 Within this context, the provided guidelines may be used as a template
 for parallelization of computationally-expensive tasks within the GRASS
 environment.
\end_layout

\begin_layout Subsection
Parallel computation on computer clusters
\end_layout

\begin_layout Standard
Considering the high computational power needed not only for geographic
 analysis, but also for predicting the radio-coverage of a real mobile network,
 the use of a computer cluster is required.
 A computer cluster is a group of interconnected computers that work together
 as a single system.
 To reach high levels of parallel performance and scalability, this work
 discusses in detail the key steps of parallel decomposition of big data
 sets and the distribution of the computational load among the computing
 nodes that belong to the cluster.
 As a practical example for introducing the above-mentioned principles,
 we use the radio-coverage prediction problem for real mobile networks.
\end_layout

\begin_layout Standard
Computer clusters typically consist of several commodity PCs connected through
 a high-speed local network with a distributed file system, like NFS 
\begin_inset CommandInset citation
LatexCommand citep
key "Shepler_Network_file_system:2003"

\end_inset

.
 One such system is the DEGIMA cluster 
\begin_inset CommandInset citation
LatexCommand citep
key "Hamada_Cluster_of_GPUs:2010"

\end_inset

 at the Nagasaki Advanced Computing Center of the Nagasaki University.
 This system ranked in the TOP 500 list of supercomputers until June 2012
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.top500.org
\end_layout

\end_inset

, and in June 2011 held the third place of the Green 500 list
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.green500.org
\end_layout

\end_inset

 as one of the most energy-efficient supercomputers in the world.
\end_layout

\begin_layout Standard
It is worth pointing out that the condition of the cluster working as a
 single system is not necessary in the context of this study.
 The introduced approaches work equally well over any set of networked computers.
 The decision of using a the high-end DEGIMA cluster is related with the
 necessity of simulating very large runs in order to assert the benefits
 and drawbacks of the presented methodology.
\end_layout

\begin_layout Subsection
Objectives
\begin_inset CommandInset label
LatexCommand label
name "sub:Objectives"

\end_inset


\end_layout

\begin_layout Standard
The main goal of this work is to introduce parallel-programming principles,
 which, combined with a relational database, unleash the computing power
 of a group of networked desktop computers.
 We put an extra effort to exploit every computing node to its maximum,
 disregarding the type of hardware available or its relative performance
 when compared to other nodes in the cluster.
 Moreover, we target a decoupled and asynchronous architecture, which, backed
 by a relational database, shows excellent scalability and load-balancing
 properties.
 Yet keeping the overall complexity of the system to a bearable minimum.
\end_layout

\begin_layout Standard
As a proof-of-concept, we develop a radio prediction tool targeted at large
 real-world network environments, such as the ones currently deployed by
 several mobile operators around the world.
 To achieve this, we present a high-performance parallel radio prediction
 tool (PRATO) for radio networks.
 Therefore, our focus is on the performance and scalability of PRATO, while
 other more dynamic aspects of radio networks are not considered.
 Among these aspects are code distributions, details of (soft) handover,
 and dynamics related to radio resource management.
\end_layout

\begin_layout Standard
The performance evaluation of PRATO in a distributed computing environment
 is a major objective of this work, since its implementation is founded
 on principles which are the core of this study.
 Furthermore, by presenting a detailed description of the design and implementat
ion of the parallel version of PRATO, we provide guidelines and patterns
 on how to achieve high efficiency levels of task parallelization in GRASS
 GIS, while keeping the overall complexity of the system at its minimum.
 Additionally, we introduce techniques to overcome several obstacles encountered
 during our research as well as in related work, which significantly improve
 the quality and performance of the presented implementation, e.g.
 the inability to use GRASS in a threaded environment, lowering overhead
 of I/O operations, saving simulation results asynchronously and independently
 from GRASS, and improving load balancing with a new message-passing technique.
\end_layout

\begin_layout Standard
The radio-coverage prediction problem presents common points with many different
 problems within geographic information sciences.
 Each transmitter within the radio network works as a point of interest,
 around which some phenomena is analyzed.
 As an example, think about wild fire control, where the fire starts at
 several points over a given area 
\begin_inset CommandInset citation
LatexCommand citep
key "Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

.
 Weather-related analysis also follows this pattern 
\begin_inset CommandInset citation
LatexCommand citep
key "Huang_Using_adaptively_coupled_models_and_high_performance_computing_for_enabling_the_computability_of_dust_storm_forecasting:2012"

\end_inset

.
 Moreover, agent-based simulations present another use case for this approach,
 where the agents are the points of interest and the calculation radius
 their influence neighborhood 
\begin_inset CommandInset citation
LatexCommand citep
key "Gong_Parallel_agent_based_simulation_of_individual_level_spatial_interactions_within_a_multicore_computing_environment:2012"

\end_inset

.
 Further examples of possible mappings for different problems are given
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Related-work"

\end_inset

.
\end_layout

\begin_layout Standard
The paper is organized as follows.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Description-of-the-radio-coverage-prediction-tool"

\end_inset

 gives a description of the radio-coverage prediction problem and the implemente
d tool, including the propagation model and GRASS GIS.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Design-and-implementation"

\end_inset

 concentrates on the design principles and implementation details of the
 radio propagation tool, for the serial and parallel versions.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulations"

\end_inset

 discusses the experimental results and their analysis.
 Finally, Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Related-work"

\end_inset

 gives an overview of relevant publications, describing how they relate
 to our work, before drawing some conclusions.
\end_layout

\begin_layout Section
Radio-coverage prediction for mobile networks 
\begin_inset CommandInset label
LatexCommand label
name "sec:Description-of-the-radio-coverage-prediction-tool"

\end_inset


\end_layout

\begin_layout Subsection
Background
\end_layout

\begin_layout Standard
The coverage planning of radio networks remains a key problem that all mobile
 operators have to deal with.
 Moreover, it has proven to be a fundamental issue not only in GSM networks,
 but also in modern standards such as the third generation (3G) UMTS and
 the fourth generation (4G) LTE Advanced 
\begin_inset CommandInset citation
LatexCommand citep
key "Saleh_On_the_coveraga_extension_in_LTE_networks:2010,Shabbir_Comparison_of_radio_propagation_models:2011,Siomina:Minimum.pilot.power.for.service.coverage,Valcarce_Applying.FDTD.to.the.coverage.prediction.of.WiMAX:2009"

\end_inset

.
 One of the primary objectives of mobile-network planning is to efficiently
 use the allocated frequency band to assure that some geographic area of
 interest can be satisfactorily reached with the base stations of the network.
 To this end, radio-coverage prediction tools are of great importance as
 they allow network engineers to test different network configurations before
 physically implementing the changes.
 Nevertheless, radio-coverage prediction is a complex task, mainly due to
 the wide range of various combinations of hardware and configuration parameters
 which have to be analyzed in the context of different environments.
 The complexity of the problem means that radio-coverage prediction is a
 computationally-intensive and time-consuming task, hence the importance
 of fast and accurate tools.
 Additionally, since the number of deployed transmitters keeps growing with
 the adoption of modern standards 
\begin_inset CommandInset citation
LatexCommand citep
key "Saleh_On_the_coveraga_extension_in_LTE_networks:2010"

\end_inset

, there is a clear need for a radio propagation tool that is able to cope
 with larger work loads in a feasible amount of time.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Despite various options of commercial tools specialized in radio-propagation
 modeling, the common thread among them is the restricted nature of its
 usage, mostly dominated by black-box implementations.
 This fact induces lack of adaptability, sometimes even combined with cumbersome
 user interfaces that are not suitable for big batch jobs, involving thousands
 of transmitters.
 Moreover, the evolution of any commercial tool is strictly bounded to its
 vendor, forcing the user to adapt its work-flow to it, when the opposite
 situation should be preferred.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
PRATO is a high-performance radio-prediction tool for GSM (2G), UMTS (3G)
 and LTE (4G) radio networks.
 It is implemented as a module for the GRASS GIS (for details of GRASS see
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GRASS-GIS"

\end_inset

).
 It can be used for planning the different phases of a new radio-network
 installation, as well as a support tool for maintenance activities related
 to network troubleshooting or upgrading.
\end_layout

\begin_layout Standard
As a reference implementation, we have used the publicly available radio
 coverage prediction tool, developed in 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

.
 The authors of this work have developed a modular radio coverage tool that
 performs separate calculations for radio-signal path loss and antenna radiation
 patterns, also taking into account different configuration parameters,
 such as antenna tilting, azimuth and height.
 The output result, saved as a raster map, is the maximum signal level over
 the target area, in which each point represents the received signal from
 the best serving transmitter.
 This work implements some well-known radio propagation models, e.g.
 Okumura-Hata and COST 231, the later is explained in more detail in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:COST-231-model"

\end_inset

.
 Regarding the accuracy of the predicted values, the authors 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

 report comparable results to those of a state-of-the-art commercial tool.
 Furthermore, to ensure that our implementation is completely compliant
 with the afore-mentioned reference, we have designed a comparison test
 that consists of running both tools with the same set of input parameters.
 The test results from PRATO and the reference implementation are identical
 in all tested cases.
\end_layout

\begin_layout Subsection
Propagation modeling
\begin_inset CommandInset label
LatexCommand label
name "sub:COST-231-model"

\end_inset


\end_layout

\begin_layout Standard
The COST-231 Walfisch-Ikegami radio-propagation model was introduced as
 an extension of the well-known COST Hata model 
\begin_inset CommandInset citation
LatexCommand citep
key "Shabbir_Comparison_of_radio_propagation_models:2011,Sarkar_Survey_of_radio_propagation_models:2003"

\end_inset

, designed for frequencies above 2000
\begin_inset space ~
\end_inset

MHz.
 The suitability of this model comes from the fact that it distinguishes
 between line-of-sight (LOS) and non-line-of-sight (NLOS) conditions.
 Equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cost231_LOS-1"

\end_inset

) describes the path loss when there is LOS between the transmitter and
 the receiver.
 On the other hand, in NLOS conditions, the path loss is calculated as in
 Equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cost231_NLOS-1"

\end_inset

).
\end_layout

\begin_layout Standard
In this work, as well as in the reference implementation 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

, the terrain profile is used for LOS determination.
 The wave-guide effect in streets of big cities is not taken into account,
 because the building data is not available.
 In order to compensate the missing data, we include a correction factor,
 based on the land usage (clutter data).
 This technique is also adopted by other propagation models for radio networks,
 like the artificial neural networks macro-cell model developed in 
\begin_inset CommandInset citation
LatexCommand citep
key "Neskovic_Microcell_electric_field_strength_prediction_model:2010"

\end_inset

.
 Consequently, we introduce an extra term for signal loss due to clutter
 (
\begin_inset Formula $L_{\textrm{CLUT}}$
\end_inset

), thus defining the LOS and NLOS path losses as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
PL_{\textrm{LOS}}(d)=42.64+26\log(d)+20\log(F)+L_{\textrm{CLUT}}\label{eq:cost231_LOS-1}
\end{equation}

\end_inset

and
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
PL_{\textrm{NLOS}}(d)=L_{0}+L_{\textrm{RTS}}+L_{\textrm{MSD}}+L_{\textrm{CLUT}},\label{eq:cost231_NLOS-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $d$
\end_inset

 is the distance (in kilometers) from the transmitter to the receiver point,
 
\begin_inset Formula $F$
\end_inset

 is the frequency (in MHz), 
\begin_inset Formula $L_{0}$
\end_inset

 is the attenuation in free space (in dB), 
\begin_inset Formula $L_{\textrm{RTS}}$
\end_inset

 represents the diffraction from roof top to street, and 
\begin_inset Formula $L_{\textrm{MSD}}$
\end_inset

 represents the diffraction loss due to multiple obstacles.
\end_layout

\begin_layout Section
Design and implementation 
\begin_inset CommandInset label
LatexCommand label
name "sec:Design-and-implementation"

\end_inset


\end_layout

\begin_layout Subsection
GRASS Geographical Information System
\begin_inset CommandInset label
LatexCommand label
name "sub:GRASS-GIS"

\end_inset


\end_layout

\begin_layout Standard
As the software environment for PRATO we have chosen GRASS (Geographic Resources
 Analysis Support System) 
\begin_inset CommandInset citation
LatexCommand citep
key "neteler2002:GRASS_GIS"

\end_inset

, which is a free and open-source software project that implements a fully
 featured GIS.
 This GIS software was originally developed at the US Army Construction
 Engineering Research Laboratories and it ships with a wide range of analytical,
 data-management, and visualization capabilities.
 Currently, the development of GRASS GIS is supported by a growing community
 of volunteer developers.
\end_layout

\begin_layout Standard
The use of GRASS GIS as an environment for PRATO presents many advantages.
 First, GRASS is arguably the most widely used open source GIS available.
 With more than 30 years of active development and a continuously growing
 community of users and developers, it provides a working environment with
 the tools and flexibility needed for industrial and academic use.
 Indeed, a quick search for research papers related to GRASS GIS confirm
 this.
 Second, the current development of GRASS is primarily Linux-based.
 Since the field of high-performance computing is dominated by Linux and
 UNIX systems, an environment with Linux support is preferred for this work.
 Software licensing is another important consideration for choosing GRASS,
 since it is licensed under the GNU Public License 
\begin_inset CommandInset citation
LatexCommand citep
key "Stallman_GNU_License:1991"

\end_inset

 and imposes the availability of the source code.
 This allows us to make potential modifications to the system, thus adapting
 it for the parallel computation environment.
 Moreover, being an open system, GRASS provided us with a great deal of
 useful built-in functionality, capable of operating with raster and vector
 topological data that can be stored in an internal format or a relational
 database.
 For additional information about the GRASS, we refer the reader to the
 numerous guides and tutorials available online.
\end_layout

\begin_layout Subsection
Design of the serial version
\end_layout

\begin_layout Standard
This section describes the different functions contained in the serial version
 of PRATO, which is implemented as a GRASS module.
 Their connections and data flow are depicted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

, where the parallelograms of the flow diagram represent input/output (I/O)
 operations.
 
\end_layout

\begin_layout Standard
Our design follows a similar internal organization as the radio planning
 tool presented in 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

, but with some essential differences.
 Specifically, our approach employs a direct connection to an external database
 server for intermediate result saving, instead of the slow built-in GRASS
 database drivers.
 To explicitly avoid tight coupling with a specific database vendor, the
 generated output is formatted in plain text, which is then forwarded to
 the database server.
 Any further processing is achieved by issuing a query over the database
 tables that contain the partial results for each of the processed transmitters.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Specifically, we have decided to avoid the modular design to prevent the
 overhead of I/O operations for communicating data between the components
 of the modular architecture.
 Instead, we have chosen a monolithic design, in which all the steps for
 generating the radio coverage prediction are calculated inside one GRASS
 module.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
3.1.1 Read input parameters
\end_layout

\begin_layout Plain Layout
All input data are read in the first step (see 
\begin_inset Quotes eld
\end_inset

Read input data
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

), e.g.
 digital elevation model, clutter data, transmitter configurations, and
 other service-dependent settings.
 Their format differs based on the data they contain, namely:
\end_layout

\begin_layout Itemize
GRASS raster files are used for the digital elevation model and clutter
 data, whereas
\end_layout

\begin_layout Itemize
a text file is used for the transmitter configurations and other simulation-depe
ndent options.
\end_layout

\begin_layout Plain Layout
Since the module accepts a considerable amount of input parameters, they
 are read from a text-based initialization (INI) file.
 This is far more practical than passing them as command-line parameters,
 which would make them error-prune and difficult to read.
 Besides, the INI file may contain configuration parameters for many transmitter
s.
 The user selects which one(s) to use at run-time by passing a command-line
 option.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/serial_implementation_flow_diagram.eps
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of the serial version.
\emph default

\begin_inset CommandInset label
LatexCommand label
name "fig:serial_version_flow_diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Isotropic path-loss calculation
\begin_inset CommandInset label
LatexCommand label
name "sub:Path-loss-for-isotrophic-source"

\end_inset


\end_layout

\begin_layout Standard
This step starts by calculating which receiver points, 
\begin_inset Formula $r$
\end_inset

, are within the specified transmission radius (see 
\begin_inset Quotes eld
\end_inset

transmission radius
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

).
 For these points, the LOS and NLOS conditions are calculated, with respect
 to the transmitter (see 
\begin_inset Quotes eld
\end_inset

Calculate LOS/NLOS
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

).
 The following step consists of calculating the path loss for an isotropic
 source (or omni antenna).
 This calculation is performed by applying the COST-231 path-loss model,
 which was previously introduced in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:COST-231-model"

\end_inset

, to each of the points within the transmission radius around the transmitter.
 Depending on whether the receiver point 
\begin_inset Formula $r$
\end_inset

 is in LOS or NLOS, either Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cost231_LOS-1"

\end_inset

) or Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cost231_NLOS-1"

\end_inset

) is respectively applied (see 
\begin_inset Quotes eld
\end_inset

Apply COST-231, LOS
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Apply COST-231, NLOS
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:path_loss-example"

\end_inset

 shows a portion of a raster map with an example result of the isotropic
 path-loss calculation.
 The color scale is given in dB, indicating the signal loss from the isotropic
 source, located in the center.
 Also, the hilly terrain is clearly distinguished due to LOS and NLOS conditions
 from the signal source.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/isotrophic_calculation.eps
	lyxscale 30
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Example of raster map, showing the result of a path-loss calculation from
 an isotropic source.
\begin_inset CommandInset label
LatexCommand label
name "fig:path_loss-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/antenna_calculation.eps
	lyxscale 30
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Example of raster map, showing the antenna influence over the isotropic
 path-loss result.
\begin_inset CommandInset label
LatexCommand label
name "fig:antenna-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Antenna diagram influence
\begin_inset CommandInset label
LatexCommand label
name "sub:Antenna-diagram-influence"

\end_inset


\end_layout

\begin_layout Standard
This step considers the antenna radiation diagram of the current transmitter
 and its influence over the isotropic path-loss calculation (see 
\begin_inset Quotes eld
\end_inset

Calculate antenna influence
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

).
 Working on the in-memory results generated by the previous step, the radiation
 diagram of the antenna is taken into account, including beam direction,
 electrical and mechanical tilt.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:antenna-example"

\end_inset

 shows a portion of a raster map, where this calculation step has been applied
 to the results from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:path_loss-example"

\end_inset

.
 Notice the distortion of the signal propagation that the antenna has introduced.
\end_layout

\begin_layout Subsubsection
Transmitter path-loss prediction
\begin_inset CommandInset label
LatexCommand label
name "sub:Transmitter-path-loss-prediction"

\end_inset


\end_layout

\begin_layout Standard
In this step, the coverage prediction of the transmitter is saved in its
 own database table (see 
\begin_inset Quotes eld
\end_inset

Save transmitter path-loss to DB
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

), thus considerably enhancing the write performance during the result-dumping
 phase, which involves saving the path-loss results.
 This is accomplished by connecting the standard output of the developed
 module with the standard input of a database client.
 Naturally, the generated plain text should be understood by the database
 server itself.
\end_layout

\begin_layout Subsubsection
Coverage prediction
\begin_inset CommandInset label
LatexCommand label
name "sub:Final-coverage-prediction"

\end_inset


\end_layout

\begin_layout Standard
The final radio coverage prediction, containing an aggregation of the partial
 path-loss results of the involved transmitters, is created in this step
 (see 
\begin_inset Quotes eld
\end_inset

Create final coverage prediction
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:serial_version_flow_diagram"

\end_inset

).
 The received signal strength from each of the transmitters is calculated
 as the difference between its transmit power and path loss for the receiver's
 corresponding position.
 This is done for each point in the target area by executing an SQL query
 over the tables containing the path-loss predictions of each of the processed
 transmitters.
\end_layout

\begin_layout Standard
Finally, the output raster is generated, using the GRASS built-in modules
 
\begin_inset Formula $v.in.ascii$
\end_inset

 and 
\begin_inset Formula $v.to.rast$
\end_inset

, which create a raster map using the results of the above-mentioned query
 as input.
 The raster map contains the maximum received signal strength for each individua
l point, as shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:output_raster_example"

\end_inset

.
 In this case, the color scale is given in dBm, indicating the received
 signal strength from the transmitters.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/final_coverage.eps
	lyxscale 30
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Example of raster map, displaying the final coverage prediction of several
 transmitters.
 The color scale is given in dBm, indicating the received signal strength.
\begin_inset CommandInset label
LatexCommand label
name "fig:output_raster_example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multi-paradigm parallel programming
\end_layout

\begin_layout Standard
The implementation methodology adopted for PRATO follows a multi-paradigm
 parallel programming approach in order to fully exploit the resources of
 each of the nodes in a computing cluster.
 To effectively use a shared memory multi-processor, PRATO uses POSIX threads
 to implement parallelism 
\begin_inset CommandInset citation
LatexCommand citep
key "Butenhof_Programming.with.POSIX.threads:1997"

\end_inset

.
 By using POSIX threads, multiple threads can exist within the same process
 while sharing its resources.
 For instance, an application using POSIX threads can execute multiple threads
 in parallel by using the cores of a multi-core processor, or use the system
 resources more effectively, thus avoiding process execution-halt due to
 I/O latency by using one thread for computing while a second thread waits
 for an I/O operation to complete.
 
\end_layout

\begin_layout Standard
To use the computing resources of a distributed memory system, such as a
 cluster of processors, PRATO uses the Message Passing Interface (MPI) 
\begin_inset CommandInset citation
LatexCommand citep
key "Gropp_Using_MPI:1999"

\end_inset

.
 MPI is a message-passing standard which defines syntax and semantics designed
 to function on a wide variety of parallel computers.
 MPI enables multiple processes running on different processors of a computer
 cluster to communicate with each other.
 MPI was designed for high performance on both massively parallel machines
 and on workstation clusters.
 It has been developed by a broadly based committee of vendors, developers,
 and users.
\end_layout

\begin_layout Standard
In order to make the text more clear and to differentiate between the programmin
g paradigms used from here on, we will refer to a POSIX thread simply as
 a `thread' and a MPI proccess as a `process'.
\end_layout

\begin_layout Subsection
Design of the parallel version
\begin_inset CommandInset label
LatexCommand label
name "sub:Design-parallel"

\end_inset


\end_layout

\begin_layout Standard
Keeping our focus on the usability and performance of PRATO, we are introducing
 a new distributed implementation to overcome computational-time constraints
 that prevented the reference implementation from tackling big problem instances
 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

.
\end_layout

\begin_layout Standard
Some authors have already published their work on implementing parallel
 versions of GRASS modules for solving different time-consuming tasks 
\begin_inset CommandInset citation
LatexCommand citep
key "Akhter_Porting_GRASS_raster_module_to_distributed_computing:2007,Campos_Parallel_modelling_in_GIS:2012,Sorokine_Parallel_visualization_in_GRASS:2007"

\end_inset

.
 However, one major drawback of GRASS as a parallelization environment is
 that it is not thread-safe, meaning that concurrent changes to the same
 data set have undefined behavior.
 To overcome this problem, we present a technique that saves the simulation
 results asynchronously and independently from the GRASS environment, e.g.
 into an external database system.
 This database system works also as an input source, serving data to GRASS,
 whether it is used to aggregate the partial results of the path-loss prediction
 or to visualize them.
 It is worth pointing out that any database system may be used.
 By this we mean relational, distributed 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozsu_Principles_of_distributed_database_systems:2011"

\end_inset

 or even those of the NoSQL type 
\begin_inset CommandInset citation
LatexCommand citep
key "Stonebraker_SQL_databases_vs_NoSQL_databases:2010"

\end_inset

.
 Nevertheless, in this study we use a central relational database system,
 since they are the most popular and widely available ones.
\end_layout

\begin_layout Standard
We also introduce a methodology that allows the parallel implementation
 to be almost completely GRASS independent.
 This means that a GRASS installation is needed on only one of the nodes,
 i.e.
 the master node of the target computer cluster, thus improving the usability
 of the introduced methods.
 Also, a message-passing technique is proposed to distribute the work-load
 among nodes hosting the worker processes.
 Using this technique, computing nodes featuring more capable hardware receive
 more work than those with weaker configurations, thus ensuring a better
 utilization of the available computing resources despite hardware diversity.
\end_layout

\begin_layout Subsubsection
Master process
\begin_inset CommandInset label
LatexCommand label
name "sub:Master-process"

\end_inset


\end_layout

\begin_layout Standard
As it has been suggested before, the parallel version of PRATO follows a
 master-worker model.
 The master process, for which the flow diagram is given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

, is the only component that should be run from within the GRASS environment.
 As soon as the master process starts, the input parameters are read.
 This step corresponds to 
\begin_inset Quotes eld
\end_inset

Read input data
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

, and it is done in a similar way as in the serial version.
 In the next step, the master process dynamically initiates the worker processes
 using the available computing nodes (see 
\begin_inset Quotes eld
\end_inset

Dynamic worker-process spawning
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

), based on the amount of transmitters (or points of interest) for which
 the coverage prediction should be calculated.
 This means that master process never starts more worker processes than
 there are transmitters to be processed.
 However, if the number of transmitters is larger than the amount of available
 computing nodes, the master process can assign several transmitters to
 each of the worker processes.
 For distributing the work among the worker processes, the master process
 proceeds to decompose the loaded raster data into arrays of basic-data-type
 elements, e.g.
 floats or doubles, before dispatching them to the multiple worker processes
 (see 
\begin_inset Quotes eld
\end_inset

Input data broadcasting
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

).
 In this case, the decomposition of the data applies to the digital-elevation
 and the clutter data only, but it could be applied to any point-based data
 set, vector or raster.
 In the next step, the master process starts a message-driven processing
 loop (see 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

), which main task is to assign and distribute the configuration data of
 different transmitters among idle worker processes.
 If using points of interest instead of transmitters, this configuration
 data translates into local properties that differ among points of interest.
\end_layout

\begin_layout Standard
The flow diagram shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:processing_loop_in_master_process"

\end_inset

 depicts in more detail the steps inside the 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 step of the master process.
 In the processing loop, the master process starts by checking the available
 worker processes, which will calculate the radio coverage prediction for
 the next transmitter.
 It is worth pointing out that this step also serves as a stopping condition
 for the processing loop itself (see 
\begin_inset Quotes eld
\end_inset

Any worker still on?
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:processing_loop_in_master_process"

\end_inset

).
 The active worker processes inform the master process they are ready to
 compute by sending an idle message (see 
\begin_inset Quotes eld
\end_inset

Wait for idle worker
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:processing_loop_in_master_process"

\end_inset

).
 The master process then announces the idle worker process it is about to
 receive new data for the next calculation, and it dispatches the complete
 configuration of the transmitter to be processed (see 
\begin_inset Quotes eld
\end_inset

Send keep-alive message
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Send transmitter data
\begin_inset Quotes erd
\end_inset

 steps, respectively, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:processing_loop_in_master_process"

\end_inset

).
 This is only done in case there are transmitters for which the coverage
 prediction has yet to be calculated (see 
\begin_inset Quotes eld
\end_inset

Any transmitters left?
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:processing_loop_in_master_process"

\end_inset

).
 The processing loop of the master process continues to distribute transmitter
 data among worker processes, which asynchronously become idle as they finish
 the coverage-prediction calculations for the transmitters they have been
 assigned by the master process.
 When there are no more transmitters left, all the worker processes announcing
 they are idle will receive a shutdown message from the master process,
 indicating them to stop running (see 
\begin_inset Quotes eld
\end_inset

Send stop message
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:processing_loop_in_master_process"

\end_inset

).
 The master process will keep doing this until all worker processes have
 finished (see 
\begin_inset Quotes eld
\end_inset

Any worker still on?
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:processing_loop_in_master_process"

\end_inset

), thus fulfilling the stopping condition of the processing loop.
\end_layout

\begin_layout Standard
Finally, the last step of the master process is devoted to creating the
 final output of the calculation, e.g.
 a raster map (see 
\begin_inset Quotes eld
\end_inset

Create final coverage prediction
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

).
 The final coverage prediction of all transmitters is an aggregation from
 the individual path-loss results created by each of the worker processes
 during the 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 phase in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

, which provides the source data for the final raster map.
 The aggregation of the individual transmitter path-loss results is accomplished
 by issuing an SQL query over the database tables containing the partial
 results, in a similar way as in the serial version.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/master_process_flow_diagram.eps
	width 48col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of the master process.
\begin_inset CommandInset label
LatexCommand label
name "fig:master_process"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/master_processing_loop_flow_diagram.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of the 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 step of the master process.
\begin_inset CommandInset label
LatexCommand label
name "fig:processing_loop_in_master_process"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Worker processes
\end_layout

\begin_layout Standard
An essential characteristic of the worker processes is that they are completely
 independent from GRASS, i.e.
 they do not have to run within the GRASS environment nor use any of the
 GRASS libraries to work.
 This aspect significantly simplifies the deployment phase to run PRATO
 on a computer cluster, since no GRASS installation is needed on the computing
 nodes hosting the worker processes.
\end_layout

\begin_layout Standard
The computations of the worker processes, for which the flow diagram is
 given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

, are initialized by data that are received from the master process at initializ
ation time (see 
\begin_inset Quotes eld
\end_inset

Receive broadcasted data
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

).
 It is important to note that the received data contain the transmitter
 and terrain-profile information which is common to all the coverage-prediction
 calculations, therefore making each worker process capable of processing
 any given transmitter.
\end_layout

\begin_layout Standard
The reason for the worker processes to be independent from GRASS arises
 from the design of GRASS itself.
 Specifically, the existing GRASS library, distributed with the GRASS GIS
 package, is not thread-safe, because GRASS was designed as a system of
 small stand-alone modules and not as a library for multi-threaded programs
 
\begin_inset CommandInset citation
LatexCommand citep
key "Blazek_GRASS_server:2004"

\end_inset

.
 Because of this limitation, it is not an option for a parallel implementation
 to create separate threads for each worker process, since this would mean
 worker processes should wait for each other to finish, before accessing
 the target data.
 Consequently, the scalability of such implementation would be very limited.
\end_layout

\begin_layout Standard
One possible solution to overcome this limitation would be to save the transmitt
er path-loss prediction result through the master process, thus avoiding
 concurrent access.
 However, sending intermediate results back to the master process from the
 workers would represent a major bottleneck for the scalability of the parallel
 version, since the results generated by a parallel computation would have
 to be serially processed by the master process alone.
 Instead, our approach allows each of the worker processes to output its
 results into an external database server, following an asynchronous and
 decoupled design.
 Each of the transmitter path-loss prediction results are saved in separate
 tables, i.e.
 one for each transmitter or point of interest.
 Moreover, worker processes do this from an independent thread, which runs
 concurrently with the calculation of the next transmitter received from
 the master process.
 The overlap between calculation and communication achieved by the use of
 an auxiliary thread completely hides the latency created by the result
 dumping task, and makes better use of the system resources.
\end_layout

\begin_layout Standard
After the broadcasted data are received by all the worker processes, each
 worker process proceeds to inform the master process that it is ready (i.e.
 in an idle state) to receive the transmitter-configuration data that defines
 which transmitter path-loss prediction to perform (see 
\begin_inset Quotes eld
\end_inset

Send idle message
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

).
 If the master process does not instruct to stop processing (see 
\begin_inset Quotes eld
\end_inset

Has stop message arrived?
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

), the worker process collects the transmitter configuration sent (see 
\begin_inset Quotes eld
\end_inset

Receive transmitter data
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

).
 However, in case a stop message is received, the worker process will wait
 for result-dumping threads to finish (see 
\begin_inset Quotes eld
\end_inset

Wait for result-dump threads
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

) before shutting down.
 The coverage calculation itself follows a similar design as the serial
 version (see 
\begin_inset Quotes eld
\end_inset

Coverage calculation
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

) and it is executed for the received transmitter or point of interest.
\end_layout

\begin_layout Standard
As it was mentioned before, the worker process launches an independent thread
 to save the path-loss prediction of the target transmitter to a database
 table (see 
\begin_inset Quotes eld
\end_inset

Threaded save path-loss to DB
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

).
 It is important to note that there is no possibility of data inconsistency
 due to the saving task being executed inside a thread, since path-loss
 data from different workers belong to different transmitters and are, at
 least at this point of the process, mutually exclusive.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/worker_process_flow_diagram.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Flow diagram of a worker process.
\begin_inset CommandInset label
LatexCommand label
name "fig:worker_process_flow_diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/master_worker_communication_diagram.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Communication diagram, showing message passing between master and one worker
 process.
\begin_inset CommandInset label
LatexCommand label
name "fig:master_worker_communication"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Master-worker communication
\begin_inset CommandInset label
LatexCommand label
name "sub:Master-worker-communication"

\end_inset


\end_layout

\begin_layout Standard
The selected message-passing technique introduced in this work enables a
 better use of the available computing resources, both in terms of scalability
 and load balancing.
 This argument is supported by the experimental results, introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulations"

\end_inset

.
\end_layout

\begin_layout Standard
The first reason to implement the message-passing technique is to support
 heterogeneous computing environments.
 In particular, our approach focuses on taking full advantage of the hardware
 of each computing node, thus explicitly avoiding the possible bottlenecks
 introduced by the slowest computing node in the cluster.
 In other words, computing nodes that deliver better performance get more
 calculations assigned to the worker processes they host.
 The main advantages of this technique are simplicity and negligible overhead,
 which contrast with more elaborated approaches for parallel-task allocation
 in heterogeneous clusters 
\begin_inset CommandInset citation
LatexCommand citep
key "Bosque_A_parallel_computational_model_for_heterogenous_clusters:2006"

\end_inset

.
\end_layout

\begin_layout Standard
A second reason for selecting a message-passing technique is related to
 the flexibility for load balancing, which is of great importance on heterogeneo
us cluster.
 This can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:worker_process_flow_diagram"

\end_inset

 where the master process, before delivering the transmitter-configuration
 data, sends a message to the worker process indicating that it is about
 to receive more work.
 This a priori meaningless message has a key role in correctly supporting
 computer clusters.
 In general, there are many different ways a parallel program can be executed,
 because the steps from the different processes can be interleaved in various
 ways and a process can make non-deterministic choices 
\begin_inset CommandInset citation
LatexCommand citep
key "Siegel_Verification_of_halting_properties_for_MPI_programs:2007"

\end_inset

, which may lead to situations such as race conditions 
\begin_inset CommandInset citation
LatexCommand citep
key "Clemencon_MPI_Race_detection:1995"

\end_inset

 and deadlocks.
 A deadlock occurs whenever two or more running processes are waiting for
 each other to finish, and thus neither ever does.
 To prevent the parallel version of PRATO from deadlocking, message sending
 and receiving should be paired, being equal number of send and receive
 messages on the master and worker sides 
\begin_inset CommandInset citation
LatexCommand citep
key "Siegel_Verification_of_halting_properties_for_MPI_programs:2007"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_worker_communication"

\end_inset

 depicts a diagram of the master-worker message passing, from which the
 transmitter-data transmission has been excluded for clarity.
 Note how each idle message sent from the worker process is paired with
 an answer from the master process, whether it is a keep-alive or a stop
 message.
\end_layout

\begin_layout Section
Simulations 
\begin_inset CommandInset label
LatexCommand label
name "sec:Simulations"

\end_inset


\end_layout

\begin_layout Standard
This section presents the simulations and analysis of the parallel version
 of PRATO.
 Our aim is to provide an exhaustive analysis of the performance and scalability
 of the parallel implementation in order to determine if the objectives
 of this work are fulfilled.
 The most common usage case for PRATO is to perform a radio-coverage prediction
 for multiple transmitters, therefore, a straight forward parallel decomposition
 is to divide a given problem instance by transmitter, for which each coverage
 prediction is calculated by a separate worker process.
\end_layout

\begin_layout Standard
The following simulations were carried out on 34 computing nodes of the
 DEGIMA cluster.
 DEGIMA is a computer cluster located at the Nagasaki Advanced Computing
 Center (NACC), in the University of Nagasaki, Japan.
 The computing nodes are connected by a LAN, over a Gigabit Ethernet interconnec
t.
 As it has been mentioned before, the reason for using a high-end computer
 cluster as DEGIMA is to explore by experimentation the advantages and drawbacks
 of the introduced methods.
 However, this does not mean any loss of generality when applying these
 principles over a different group of networked computer, acting as a computer
 cluster.
\end_layout

\begin_layout Standard
Each computing node of DEGIMA features one of two possible configurations,
 namely:
\end_layout

\begin_layout Itemize
Intel Core i5-2500T quad-core processor CPU, clocked at 2.30 GHz, with 16
 GB of RAM; and
\end_layout

\begin_layout Itemize
Intel Core i7-2600K quad-core processor CPU, clocked at 3.40 GHz, also with
 16 GB of RAM.
\end_layout

\begin_layout Standard
During the simulation runs, the nodes equipped with the Intel i5 CPU host
 the worker processes, whereas the master process and the PostgreSQL database
 server (version 9.1.4) run each on a different computing node, featuring
 an Intel i7 CPU.
 The database server performs all its I/O operations on the local file system,
 which is mounted on a 8
\begin_inset space ~
\end_inset

GB RAM disk.
\end_layout

\begin_layout Standard
All nodes are equipped with a Linux 64-bit operating system (Fedora distribution
).
 As the message passing implementation we use OpenMPI, version 1.6.1, which
 has been manually compiled with the distribution-supplied gcc compiler,
 version 4.4.4.
\end_layout

\begin_layout Subsection
Test networks
\end_layout

\begin_layout Standard
To test the parallel performance of PRATO, we have prepared different problem
 instances that emulate real radio networks of different sizes.
 In order to create synthetic test data-sets with an arbitrary number of
 transmitters, we use the data of a group of 10 transmitters, which we randomly
 replicate and distribute over the whole target area.
 The configuration parameters of these 10 transmitters were taken from the
 LTE network deployed in Slovenia by Telekom Slovenije, d.d.
 The path-loss predictions are calculated using the COST-231.
 The digital elevation model has an area of 20,270
\begin_inset space ~
\end_inset

km
\begin_inset Formula $^{2}$
\end_inset

, with a resolution of 25
\begin_inset space ~
\end_inset

m
\begin_inset Formula $^{2}$
\end_inset

, the same as the clutter data, which contains different levels of signal
 loss based on the land usage.
 For all the points within a radius of 20
\begin_inset space ~
\end_inset

km around each transmitter, we assume that the receiver is positioned 1.5
\begin_inset space ~
\end_inset

m above the ground, and the frequency is set to 2040
\begin_inset space ~
\end_inset

MHz.
\end_layout

\begin_layout Subsection
Weak scalability
\end_layout

\begin_layout Standard
This set of simulations is meant to analyze the scalability of the parallel
 implementation in cases where the workload assigned to each process (one
 MPI process per processor core) remains constant as we increase the number
 of processor cores and the total size of the problem, i.e.
 the number of transmitters deployed over the target area is directly proportion
al to the number of processor cores and worker processes.
 We do this by assigning a constant number of transmitters per core while
 increasing the number of cores hosting the worker processes.
 Consequently, we tackle larger radio-network instances as we increase the
 number of cores.
 Here we test for the following numbers of transmitters per worker/core:
 
\begin_inset Formula $\{5,10,20,40,80\}$
\end_inset

, and increase the number of workers per core from 1 to 128 in powers of
 2.
\end_layout

\begin_layout Standard
Problems particularly well-suited for parallel computing exhibit computational
 costs that are linearly dependent on the problem size.
 This property, also referred to as algorithmic scalability, means that
 proportionally increasing both the problem size and the number of cores
 results in a roughly constant time to solution.
 Therefore, with this set of experiments, we would like to investigate how
 well-suited the coverage-prediction problem is for parallel computing environme
nts.
\end_layout

\begin_layout Subsubsection
Results and discussion
\end_layout

\begin_layout Standard
The results collected after the simulations for the weak-scalability experiments
 are shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:results_weak_scaling"

\end_inset

.
 All measurements express wall-clock times in seconds for each problem instance,
 defined as number of transmitters per core (TX/core).
 Wall-clock time represents real time that elapses from the start of the
 master process to its end, including time that passes waiting for resources
 to become available.
 They are plotted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:weak_scalability_time"

\end_inset

, 
\shape italic
\emph on
where the wall-clock time axis is expressed in base-10 logarithmic scale,
 whereas the axis representing the number of cores is expressed in base-2
 logarithmic scale.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Wall-clock times (in seconds) of the simulation results for weak scalability.
\begin_inset CommandInset label
LatexCommand label
name "tab:results_weak_scaling"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="9">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Number of cores
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
TX/core
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
128
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
92
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
99
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
118
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
122
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
124
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
125
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
126
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
140
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
152
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
171
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
175
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
177
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
179
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
180
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
182
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
244
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
260
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
278
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
282
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
284
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
285
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
287
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
290
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
451
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
470
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
491
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
497
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
502
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
504
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
509
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
865
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
892
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
920
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
925
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
928
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
931
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
937
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
948
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/weak_scaling-time_plot.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Measured wall-clock time for weak-scalability experiments as shown in Table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:results_weak_scaling"

\end_inset

.

\emph default
 
\emph on
Experiments performed assigned one MPI worker process per available core.
 The wall-clock time axis is expressed in base-10 logarithmic scale, whereas
 the axis representing the number of cores is expressed in base-2 logarithmic
 scale.
\begin_inset CommandInset label
LatexCommand label
name "fig:weak_scalability_time"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time measurements observed from the weak-scalability results show that
 the wall-clock times do not grow rapidly, especially when the number of
 cores is more than 8.
 Moreover, these times are almost constant for bigger problem instances,
 revealing that the achieved level of scalability gets close-to-linear as
 the amount of transmitters-per-core increases.
 Certainly, the parallel version of PRATO scales especially well when challenged
 with a big number of transmitters (10240 for the biggest instance) over
 128 cores.
 This fact shows PRATO would be able to calculate the radio coverage prediction
 for real networks in a feasible amount of time, since many operational
 radio networks have already deployed a comparable number of transmitters,
 e.g.
 the 3G network within the Greater London Authority area, in the UK 
\begin_inset CommandInset citation
LatexCommand citep
key "Number_of_base_stations_in_England"

\end_inset

.
 
\end_layout

\begin_layout Standard
Not being able to achieve perfect weak scalability is due to a number of
 factors.
 Specifically, the overhead time of the serial sections of the master process
 grow proportionally with the number of cores, although the total contribution
 of this overhead remains low for large problem sizes.
 Moreover, the communication overhead grows linearly with the number of
 cores used.
\end_layout

\begin_layout Standard
To confirm these arguments, we analyze the times of each of the steps taken
 by the master process relative to the total processing time.
 To this end, we have created plots for three problem instances 5, 20 and
 80 transmitters per core, which are shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:weak_scaling-relative_times"

\end_inset

.
 The relative-processing-time plots follow the formula
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
RT=\frac{t_{\textrm{rd}}+t_{\textrm{ps}}+t_{\textrm{db}}+t_{\textrm{pl}}+t_{\textrm{cp}}}{t_{\textrm{total}}},\label{eq:relative_processing_time}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $t_{\textrm{rd}}$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

Read input data
\begin_inset Quotes erd
\end_inset

 wall-clock time, 
\begin_inset Formula $t_{\textrm{ps}}$
\end_inset

 is the wall-clock time of the 
\begin_inset Quotes eld
\end_inset

Dynamic worker-process spawning
\begin_inset Quotes erd
\end_inset

 step, 
\begin_inset Formula $t_{\textrm{db}}$
\end_inset

 is the wall-clock time of the 
\begin_inset Quotes eld
\end_inset

Input data broadcasting
\begin_inset Quotes erd
\end_inset

 step, 
\begin_inset Formula $t_{\textrm{pl}}$
\end_inset

 is the wall-clock time of the 
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

 step, 
\begin_inset Formula $t_{\textrm{cp}}$
\end_inset

 is the wall-clock time of the 
\begin_inset Quotes eld
\end_inset

Create final coverage prediction
\begin_inset Quotes erd
\end_inset

 step, and 
\begin_inset Formula $t_{\textrm{total}}$
\end_inset

 is the total wall-clock processing time.
 For a reference of the different steps taking part of the master process,
 see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "31text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/weak_scaling_relative_time_plot_5.eps
	width 100col%

\end_inset


\end_layout

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "31text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/weak_scaling_relative_time_plot_20.eps
	width 100col%

\end_inset


\end_layout

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "31text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/weak_scaling_relative_time_plot_80.eps
	width 100col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Relative times for the weak-scalability experiments.

\emph on
 
\shape italic
The relative-processing time axes are expressed in linear scale, whereas
 the axes representing the number of cores are expressed in base-2 logarithmic
 scale.
\begin_inset CommandInset label
LatexCommand label
name "fig:weak_scaling-relative_times"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
From the relative-times plots, we see that, as we increase the number of
 nodes, the largest fraction of the run-time is spent on the parallel processing
 of transmitters, which scales notably well for larger problem instances.
 The plotted relative times show that there is no dependency between the
 relative processing times and the number of cores used, confirming the
 good weak-scalability properties noted before.
 Additionally, in all three plots we may observe a 
\begin_inset Quotes eld
\end_inset

jump
\begin_inset Quotes erd
\end_inset

 in the relative time for the 
\begin_inset Quotes eld
\end_inset

Input data broadcasting
\begin_inset Quotes erd
\end_inset

 step that takes place when comparing the result from 4 to 8 cores, i.e.
 from one to two computing nodes, as each node hosts 
\begin_inset Quotes eld
\end_inset

1 worker per core
\begin_inset Quotes erd
\end_inset

 or a total of 
\begin_inset Quotes eld
\end_inset

4 workers per node
\begin_inset Quotes erd
\end_inset

.
 This 
\begin_inset Quotes eld
\end_inset

jump
\begin_inset Quotes erd
\end_inset

 is due to the use of network communication when more than one computing
 node participates in the parallel processing.
 In addition, we may also conclude that the network infrastructure has not
 been saturated with the data-passing load, since the relative times for
 input-data broadcasting do not grow exponentially from 8 cores onward.
 Regarding the 
\begin_inset Quotes eld
\end_inset

Create final coverage prediction
\begin_inset Quotes erd
\end_inset

 step, we may see that as we increase the number of cores the relative times
 grow proportionally for all three problem sizes.
\end_layout

\begin_layout Subsection
Strong scalability
\begin_inset CommandInset label
LatexCommand label
name "sub:Strong-scalability"

\end_inset


\end_layout

\begin_layout Standard
This set of simulations is meant to analyze the impact of increasing the
 number of computing cores for a given problem size, i.e.
 the number of transmitters deployed over the target area does not change,
 while only the number of cores used is increased.
 Here we test for the following number of transmitters: 
\begin_inset Formula $\{64,128,256,512,1024,2048,4096\}$
\end_inset

, and increase the number of workers per core from 1 to 128 in powers of
 2 for each problem size.
\end_layout

\begin_layout Subsubsection
Results and discussion
\end_layout

\begin_layout Standard
The results of the time measurements collected after the simulations for
 the strong-scalability experiments are shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:results_strong_scaling"

\end_inset

.
 All times are expressed in seconds.
 These wall-clock time measurements are plotted in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scalability_time"

\end_inset

, 
\shape italic
\emph on
where the time axis is expressed in base-10 logarithmic scale, whereas the
 axis representing the number of cores is expressed in base-2 logarithmic
 scale.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Wall-clock times (in seconds) of the simulation results for strong scalability.
\begin_inset CommandInset label
LatexCommand label
name "tab:results_strong_scaling"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="8">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Number of transmitters
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
No.
 cores
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2048
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4096
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
714
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1392
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2740
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
5437
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
10830
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
21562
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
43217
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
386
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
734
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1419
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2791
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
5535
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
10996
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
21987
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
232
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
408
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
751
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1432
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2811
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
5549
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
11042
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
155
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
242
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
409
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
754
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1441
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2817
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
5549
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
113
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
156
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
244
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
414
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
759
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1447
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2821
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
92
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
114
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
159
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
245
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
414
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
760
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1449
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
82
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
94
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
115
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
159
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
245
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
420
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
764
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
83
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
94
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
116
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
159
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
248
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
423
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-time_plot.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Measured wall-clock time for strong-scalability experiments as shown in
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:results_strong_scaling"

\end_inset

.
 Experiments performed assigned one MPI worker process per available core.
 The wall-clock time axis is expressed in base-10 logarithmic scale, whereas
 the axis representing the number of cores is expressed in base-2 logarithmic
 scale.
\begin_inset CommandInset label
LatexCommand label
name "fig:strong_scalability_time"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time measurements show that small problem sizes per core have a relatively
 large proportion of serial work and communication overhead.
 Therefore, the performance deteriorates as the number of transmitters per
 core approaches one.
 It can be observed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scalability_time"

\end_inset

 that as we increase the number of transmitters used to solve a given problem
 size, the slope of the curve generated by the progression of wall-clock
 times tends to a flat line, i.e.
 as we increase the number of transmitters there is no reduction in compute
 time.
 This idea is more clearly noted in the test with smaller problem instances,
 e.g.
 64, 128 and 256 transmitters.
 In contrast, for the problems with a number of transmitters larger than
 512, the relative contribution of the non-parallel steps to the wall-clock
 time is smaller, and a larger portion of the time is spent on computing
 the transmitters coverage in parallel (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Design-parallel"

\end_inset

 for details on the steps of PRATO algorithm).
 A more detailed discussion of the reasons for the loss of parallel efficiency
 will be presented towards the end of this section.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-speedup_plot.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Measured speedup for strong-scalability experiments.

\emph default
 
\emph on
The speedup axis is expressed in base-2 logarithmic scale, whereas the axis
 representing the number of cores is expressed in base-2 logarithmic scale.
\begin_inset CommandInset label
LatexCommand label
name "fig:strong_scalability_speedup"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-efficiency_plot.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Measured parallel efficiency for strong-scalability experiments.

\emph default
 
\emph on
The parallel-efficiency axis is expressed in linear scale, whereas the axis
 representing the number of cores is expressed in base-2 logarithmic scale.
\begin_inset CommandInset label
LatexCommand label
name "fig:strong_scalability_efficiency"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to observe how well the application scales when compared against
 a base case, we have also measured the performance of the parallel implementati
on in terms of the speedup, which is defined as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
S(NP)=\frac{execution\, time\, for\, base\, case}{execution\, time\, for\, NP\, cores},\label{eq:speedup}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $NP$
\end_inset

 is the number of cores executing the worker processes.
 As the base case for comparisons we have chosen the parallel implementation
 running on only one core and decided against using the serial implementation.
 We consider that the serial implementation is not a good base comparison
 for the parallel results as it does not reuse resources between each transmitte
r coverage calculation and it does not overlap I/O operations with transmitter
 computations.
 In practice, this means that several concatenated runs of the serial version
 would be considerably slower than the parallel but single worker implementation
, because the serial implementation is not able to use all of the memory
 bandwidth and computing resources simultaneously.
 Therefore such comparison would be entirely biased towards the parallel
 implementation, showing super-linear scaling and speedups which would not
 be real, as the parallel version is better equipped to make use of the
 system resources by means of multiple threads.
\end_layout

\begin_layout Standard
Using the speedup metric, linear scaling is achieved when the obtained speedup
 is equal to the total number of processors used.
 However, it should be noted that perfect speedup is almost never achieved,
 due to the existence of serial stages within an algorithm and communication
 overheads of the parallel implementation 
\begin_inset CommandInset citation
LatexCommand citep
key "Cruz_Particle.Flow.Simulation:2010"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scalability_speedup"

\end_inset

 shows the speedup of the parallel implementation for up to 128 cores (running
 one worker process per node), and compares seven different problem sizes
 with 64, 128, 256, 512, 1024, 2048 and 4096 transmitters deployed over
 the target area.
 The number of transmitters used in these problem sizes are comparable to
 several operational radio networks that have already been deployed in England,
 e.g.
 Bedfordshire County with 69 base stations, Cheshire County with 132 base
 stations, Hampshire County with 227 base stations, West Midlands with 414
 base stations, and Greater London Authority with 1086 base stations 
\begin_inset CommandInset citation
LatexCommand citep
key "Number_of_base_stations_in_England"

\end_inset

.
 Moreover, consider that it is common for a single base station to host
 multiple transmitters.
 
\end_layout

\begin_layout Standard
We can see that the significant reductions in wall-clock time for large
 problem sizes shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scalability_time"

\end_inset

 are directly correlated with the speedup factors shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scalability_speedup"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "31text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-relative_time_plot_256.eps
	width 100col%

\end_inset


\end_layout

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "31text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-relative_time_plot_1024.eps
	width 100col%

\end_inset


\end_layout

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "31text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-relative_time_plot_4096.eps
	width 100col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Relative times for the strong-scalability experiments.

\emph on
 
\shape italic
The relative-processing time axes are expressed in linear scale, whereas
 the axes representing the number of cores are expressed in base-2 logarithmic
 scale.
\begin_inset CommandInset label
LatexCommand label
name "fig:strong_scaling-relative_times"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To study how well PRATO utilizes the available computing resources we consider
 the parallel efficiency of the implementation, i.e.
 how well the parallel implementation makes use of the available processor
 cores.
 The definition of parallel efficiency is as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
E(NP)=\frac{S(NP)}{NP},
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $S(NP)$
\end_inset

 is the speedup as defined in Equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:speedup"

\end_inset

), and 
\begin_inset Formula $NP$
\end_inset

 is the number of cores executing worker processes.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scalability_efficiency"

\end_inset

 shows the parallel efficiency of the parallel implementation for different
 problem sizes as we increase the number of processing cores.
 
\end_layout

\begin_layout Standard
The ideal case for a parallel application would be to utilize all available
 resources, in which case the parallel efficiency would be constantly equal
 to one as we increase the core count.
 From the plot in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scalability_efficiency"

\end_inset

, we may observe that the efficiency is less than one, hence the computational
 resources are under utilized.
 In accordance to the previous analysis, the under utilization of the computing
 resources is more significant for the smaller problem sizes, where number
 of assigned transmitters per core approaches one.
 This is due to the increased relative influence introduced by serial and
 communication overheads, without which the parallel implementation would
 not be feasible.
 On the other hand, the relative time contribution of the serial and communicati
on overheads is significantly reduced as the work-load per core increases.
 Unsurprisingly, these results confirm what it has previously been suggested
 during the weak-scaling analysis, i.e.
 it is not worth parallelizing small problem instances over a large number
 of nodes, since the time reduction due to computations that make use of
 the extra parallel resources is surpassed by the extra parallel initialization
 and communication overhead.
\end_layout

\begin_layout Standard
Similarly as in the weak-scaling test, we study the relative contribution
 of each of the steps of the master process as we increase the number of
 cores used for a fixed problem size.
 In this case, we have created plots for three problem instances, namely
 256, 1024 and 4096 transmitters, which are shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scaling-relative_times"

\end_inset

.
 The relative times shown are calculated using the formula depicted in Equation
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relative_processing_time"

\end_inset

).
\end_layout

\begin_layout Standard
We may observe the non-parallel steps comprising 
\begin_inset Quotes eld
\end_inset

Read input data
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Dynamic worker-process spawning
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Input data broadcasting
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Final coverage prediction
\begin_inset Quotes erd
\end_inset

 contribute with a larger portion of time as we increase the number of cores,
 because the total wall-clock processing time decreases.
 Additionally, the low parallel efficiency for small problem sizes, particularly
 for 256 transmitters (left-most plot in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:strong_scaling-relative_times"

\end_inset

), is validated as we see the relative small proportion of the radio-coverage
 calculation (
\begin_inset Quotes eld
\end_inset

Processing loop
\begin_inset Quotes erd
\end_inset

) compared to the serial steps of the process.
\end_layout

\begin_layout Subsection
Load balancing
\end_layout

\begin_layout Standard
In this section, we analyze the level of utilization of the computing resources
 available at the computing nodes hosting the worker processes.
 Computing-resource utilization is achieved by partitioning the computational
 workload and data across all processors.
 Efficient workload distribution strategies should be based on the processor
 speed, memory hierarchy and communication network 
\begin_inset CommandInset citation
LatexCommand citep
key "Clarke_Dynamic_load_balancing:2011"

\end_inset

.
\end_layout

\begin_layout Standard
The parallel implementation of PRATO performs load-balancing using point-to-poin
t messages (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Master-worker-communication"

\end_inset

) between master and worker processes.
 When a worker process issues an idle message (see 
\begin_inset Quotes eld
\end_inset

Send idle message
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_worker_communication"

\end_inset

), the worker process will block until the message arrives to the master
 process.
 A similar situation occurs when the master process signals a worker back,
 whether to indicate it to shutdown or to continue working.
 Since the process-to-core mapping is one-to-one, blocking messages typically
 waste processor cycles on a computing node 
\begin_inset CommandInset citation
LatexCommand citep
key "Bhandarkar_Adaptive_load_balancing_for_MPI:2001"

\end_inset

.
 Specifically, we would like to verify the penalties that such synchronization
 technique has on the scalability of the parallel implementation.
\end_layout

\begin_layout Standard
We evaluate the load empirically 
\begin_inset CommandInset citation
LatexCommand citep
key "Watts_A_practical_approach_to_dynamic_load_balancing:1998"

\end_inset

 by using the following metric as an indicator of the load balancing among
 processes:
\end_layout

\begin_layout Standard

\size small
\begin_inset Formula 
\begin{equation}
LB(NP)=\frac{minimum\, execution\, time\, among\, NP\, cores}{processing\, loop\, time\, of\, master\, process},
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $NP$
\end_inset

 is the number of cores executing worker processes.
 Taking the processing-loop time of the master process ensures we measure
 the overhead of the message passing during the time while the coverage
 prediction is being executed by the workers.
 This means that the time measurement is performed excluding the serial
 parts of the process, i.e.
 after the common data have been broadcasted to all worker processes (
\begin_inset Quotes eld
\end_inset

Input data broadcasting
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

), until the beginning of the last step (
\begin_inset Quotes eld
\end_inset

Create final coverage prediction
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:master_process"

\end_inset

).
\end_layout

\begin_layout Standard
High performance is achieved when all cores complete their work within the
 same time, hence showing a load-balancing factor of one.
 On the other hand, lower values indicate disparity between the run times
 of the various worker processes sharing the parallel task, thus reflecting
 load imbalance.
\end_layout

\begin_layout Subsubsection
Results and discussion
\end_layout

\begin_layout Standard
For this set of experiments, we have chosen the same problem sizes as for
 strong scalability in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Strong-scalability"

\end_inset

, where the coverage predictions are calculated up-to 128 cores, running
 on 32 computing nodes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/strong_scaling-load_balancing_plot.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
\emph on
Load balancing among worker processes.
\begin_inset CommandInset label
LatexCommand label
name "fig:load_balancing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
From the plot shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:load_balancing"

\end_inset

, it is clear that the influence of the message-passing overhead over the
 processing time is inversely proportional to the amount of work each worker
 process receives.
 Additionally, for the biggest problem instances (1024, 2048 and 4096 transmitte
rs), parallel-process execution times are within 95% of a perfect load-balancing
 factor, and within 90% for problem sizes with 256 and 512 transmitters,
 showing a very good performance of the dynamic task assignment, driven
 by our message-passing technique.
 For problem instances of 64 and 128 transmitters, the parallel-process
 times are within 80% of the perfect load balancing, showing that, as the
 number of transmitters per core approaches to one, latencies introduced
 by several hardware and OS-specific factors (e.g.
 TurboBoost, process affinity, etc.) are influential over the total process
 time.
 Particularly, message-passing is not able to compensate these latencies
 as it is executed only once per worker process.
\end_layout

\begin_layout Standard
It is worth pointing out that the very good load-balancing factors shown
 here are not only merit of the message-passing technique.
 The result dumping of partial path-loss predictions, performed by the worker
 processes in a separate thread into an external database server, prevents
 data synchronization from occurring at each iteration of the parallel process,
 consequently improving the load-balancing factors significantly.
\end_layout

\begin_layout Section
Related work 
\begin_inset CommandInset label
LatexCommand label
name "sec:Related-work"

\end_inset


\end_layout

\begin_layout Standard
The reported results in 
\begin_inset CommandInset citation
LatexCommand citep
key "Ozimek_Open.source.radio.coverage.prediction:2010"

\end_inset

 show a comparable quality to those of a professional radio-planning tool.
 Since the results of the conducted comparison tests showed identical results
 between PRATO and this work, we may conclude that PRATO reaches solutions
 of comparable quality to those of a professional tool.
 However, a performance comparison with this work has not been carried out,
 because it only deals with serial implementations.
 
\end_layout

\begin_layout Standard
A different example of a GIS-based open-source radio planning tool, called
 Q-Rap, has been presented in 
\begin_inset CommandInset citation
LatexCommand citep
key "QRap"

\end_inset

.
 Developed by the University of Pretoria and the Meraka Institute of South
 Africa, the software was made publicly available in May 2010.
 Its design is geared towards an end-user tool with a graphical user interface,
 not appropriate for big batch jobs involving thousands of transmitters,
 or even parallel job execution.
 It is implemented as a plug-in for the Quantum GIS (QGIS) open source system
 
\begin_inset CommandInset citation
LatexCommand citep
key "QuantumGIS"

\end_inset

.
\end_layout

\begin_layout Standard
The task-parallelization problem within the GRASS environment has been addressed
 by several authors in different works.
 For example, in 
\begin_inset CommandInset citation
LatexCommand citep
key "Campos_Parallel_modelling_in_GIS:2012"

\end_inset

, the authors present a collection of GRASS modules for watershed analysis.
 Their work concentrates on different ways of slicing raster maps to take
 advantage of a potential MPI implementation, but there are no guidelines
 for work replication.
 Moreover, the hardware specification, on which the experiments have been
 run, is missing, making it very difficult to build upon this work.
\end_layout

\begin_layout Standard
On the field of high-performance computing, the authors of 
\begin_inset CommandInset citation
LatexCommand citep
key "Akhter_Porting_GRASS_raster_module_to_distributed_computing:2007"

\end_inset

 have presented implementation examples of a GRASS raster module, used to
 process vegetation indexes for satellite images, for MPI and Ninf-G environment
s.
 The main drawback with their methodology is the compulsory use of GRASS
 libraries in all the computing nodes that take part in the parallel calculation
, making them more difficult to setup.
 Moreover, the authors explicitly acknowledge a limitation in the performance
 of their MPI implementation for big processing jobs.
 The restriction appears due to the computing nodes being fixed to a specific
 range, since the input data are equally distributed among worker processes,
 creating an obstacle for load balancing in heterogeneous environments.
 It is worth pointing out that in the parallel implementation of PRATO we
 specifically address this problem with our message-passing technique.
\end_layout

\begin_layout Standard
Similarly, in 
\begin_inset CommandInset citation
LatexCommand citep
key "Huang_Cluster_based_parallel_GIS:2011"

\end_inset

, they use the parallel inverse distance weighting interpolation algorithm
 as a parallel implementation example.
 Although it is not explicitly noted, it can be concluded that the computing
 nodes make use of the GRASS environment, again making them more difficult
 to setup.
 Moreover, since the amount of work is evenly distributed among all processes
 (including the master one), their approach would also show decreased efficiency
 in heterogeneous environments.
\end_layout

\begin_layout Standard
Some years ago, grid computing received a lot of attention as a way of accessing
 the extra computational power needed for spatial analysis of large data
 sets 
\begin_inset CommandInset citation
LatexCommand citep
key "Armstrong_Using_a_computational_grid_for_geographic_information_analysis:2005,Vouk_Cloud_computing_issues_research_and_implementations:2008,Wang_A_cybergis_framework_for_the_synthesis_of_cyberinfrastructure_GIS_and_spatial_analysis:2010"

\end_inset

.
 However, several obstacles are still preventing this technology from being
 widely used.
 Namely, its adoption requires not only hardware and software adaptations
 of the involved parts, but also a behavioral change at the human level
 
\begin_inset CommandInset citation
LatexCommand citep
key "Armstrong_Using_a_computational_grid_for_geographic_information_analysis:2005"

\end_inset

.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand citep
key "Yin_A_framework_for_integrating_GIS_and_parallel_computing_for_spatial_control_problems_a_case_study_of_wildfire_dontrol:2012"

\end_inset

, the authors present a parallel framework for GIS integration.
 Based on the principle of spatial dependency, they lower the calculation
 processing time by backing it with a knowledge database.
 The main drawback we see from this work is the implementation of a fully
 functional GIS (or 
\begin_inset Quotes eld
\end_inset

thick GIS client
\begin_inset Quotes erd
\end_inset

 as the authors call it) both on the desktop client and in the parallel
 environment.
 This precondition considerably limits the different environments within
 which this approach may be exploited, as it requires an additional implementati
on effort.
 Besides, since their implementation uses proprietary software, it reduces
 the possibility of further development an adaptation for different GIS.
 Nevertheless, our approach is easily applicable for this problem, taking
 the fire starters as point of interests and the knowledge database as our
 relational database.
 Moreover, it should not be necessary to implement a 
\begin_inset Quotes eld
\end_inset

thick GIS
\begin_inset Quotes erd
\end_inset

, since all the logic is kept at the workers, i.e.
 within the parallel environment.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand citep
key "Gong_Parallel_agent_based_simulation_of_individual_level_spatial_interactions_within_a_multicore_computing_environment:2012"

\end_inset

, the authors present an agent-based approach for simulating spatial interaction
s.
 Their approach decomposes the entire landscape into equally-sized regions,
 which are in turn processed by a different core of a multi-core CPU.
 Despite this, the agent interaction at the region border greatly affects
 the efficiency of the algorithm, showing that an asynchronous approach,
 as the one used by PRATO, would greatly improve the overall efficiency
 of the system.
 Furthermore, even though their work is geared towards CPUs with a high
 number of cores instead of a computing cluster, our approach is even more
 appropriate, since all agent communications would happen in shared memory
 instead of over a network, which would improve performance even more.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We have presented several patterns for exploiting the computing power of
 a group of networked desktop computers, namely a computer cluster, aimed
 at spatial analysis and decision support.
 The introduced techniques, combined with the use of a database system,
 deliver a platform for parallel and asynchronous computation, that is completel
y independent from the GIS used, in this case the GRASS environment.
 Consequently, a GIS installation is needed on only one of the nodes, thus
 simplifying the required system setup and greatly enhancing the applicability
 of this methodology in different environments.
\end_layout

\begin_layout Standard
Also, the proposed message-passing technique fairly distributes the work-load
 among nodes hosting the worker processes.
 Hence, computing nodes featuring more capable hardware receive more work
 than those with weaker configurations, thus maximizing utilization of the
 available computing resources.
\end_layout

\begin_layout Standard
As a proof-of-concept, we have implemented PRATO, a parallel radio-coverage
 prediction tool for GRASS GIS.
 Extensive simulations were performed on the DEGIMA computer cluster of
 the Nagasaki Advanced Computing Center.
 The results have been analyzed to determine the level of scalability of
 the implementation, as well as the impact of the introduced patterns for
 parallel-algorithm design aimed at spatial-data processing.
\end_layout

\begin_layout Standard
The conducted analysis shows that PRATO is able to calculate the radio-coverage
 prediction of real-world mobile networks in a reduced amount of time with
 a high scalability level.
 The promising results also show the great potential of our approach to
 parallelize different time-consuming tasks for GIS.
 Particularly, the gathered results contrasted with the review of related
 work suggest that our approach would be beneficial for problem solving
 in several areas of geographic information sciences.
 This is especially true for solving optimization problems, where thousands
 of simulations take part of the evaluation step during an optimization
 process.
 Still, further research is needed to fully demonstrate this point.
\end_layout

\begin_layout Standard
Encouraged by the favorable results, further work will include abstracting
 the introduced principles and methodology into a multipurpose library for
 GRASS GIS, which will be published as free and open source software.
 By implementing such tool for spatial problem solving and decision support,
 we aim at utterly validating the suitability and usefulness of the introduced
 approach.
\end_layout

\begin_layout Standard
Nevertheless, as PRATO is also free and open-source software project, it
 can be readily modified and extended to support, for example, other propagation
 models and post-processing algorithms.
 This characteristic defines a clear advantage when compared to commercial
 and closed-source tools.
\end_layout

\begin_layout Section*
Acknowledgments
\end_layout

\begin_layout Standard
This project was co-financed by the European Union, through the European
 Social Fund.
 Hamada acknowledges support from the Japan Society for the Promotion of
 Science (JSPS) through its Funding Program for World-leading Innovative
 R&D on Science and Technology (First Program).
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "manuscript"
options "tGIS"

\end_inset


\end_layout

\end_body
\end_document
